<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>네이버 지도 팝업</title>
  <style>
    body { margin:0; display:flex; flex-direction:column; height:100vh; font-family: ui-sans-serif, system-ui, -apple-system, "Apple SD Gothic Neo", "Noto Sans KR", Arial, sans-serif; }
    #controls {
      padding:10px;
      background:#f7f7f8;
      display:flex;
      align-items:center;
      gap:16px;
      border-bottom:1px solid #ececef;
    }
    #controls label { margin-right:4px; }
    .legend { display:flex; align-items:center; gap:6px; font-size:14px; color:#333; }
    .legend-marker { width:12px; height:12px; border-radius:50%; display:inline-block; }
    #map { flex:1; }

    /* ====== 팝업(커스텀 오버레이) ====== */
    .custom-popup {
      position:absolute;
      transform: translate(10px, -50%);
      background:#fff;
      border:1px solid #e5e7eb;
      border-radius:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.12);
      overflow:hidden;
      min-width: 320px;
      max-width: 460px;
      z-index: 1000;
      animation: popIn 120ms ease-out;
    }
    @keyframes popIn {
      from { opacity:0; transform: translate(10px, -50%) scale(0.98); }
      to   { opacity:1; transform: translate(10px, -50%) scale(1); }
    }

    .custom-popup__header {
      position:relative;
      padding:12px 16px 8px 16px;
      color:#fff;
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .header-title { display:flex; flex-direction:column; gap:2px; flex:1; }
    .header-title .addr { font-weight:800; font-size:15px; line-height:1.2; }
    .header-title .bname { font-weight:600; font-size:13px; opacity:.95; }

    .close-x {
      position:absolute; top:10px; right:12px;
      width:28px; height:28px;
      display:grid; place-items:center;
      border-radius:8px;
      background: rgba(255,255,255,0.15);
      border: 1px solid rgba(255,255,255,0.25);
      color:#fff; cursor:pointer; font-weight:800;
      backdrop-filter: blur(2px);
    }
    .close-x:hover { background: rgba(255,255,255,0.25); }

    /* 타입별 헤더 배경 */
    .type-real { background: linear-gradient(135deg, #16a34a, #22c55e); }
    .type-auction { background: linear-gradient(135deg, #ef4444, #f97316); }
    .type-mixed { background: linear-gradient(135deg, #64748b, #94a3b8); }

    /* 상단 필터(라벨 리스트) */
    .popup-filters {
      display:flex; gap:6px; flex-wrap:wrap; margin-top:6px;
    }
    .filter-btn {
      appearance:none; border:none; cursor:pointer;
      padding:6px 10px; border-radius:9999px;
      font-size:12px; font-weight:800; line-height:1;
      background: rgba(255,255,255,0.18);
      color:#fff; border:1px solid rgba(255,255,255,0.35);
      transition: transform .06s ease, background .12s ease;
      white-space:nowrap;
    }
    .filter-btn:hover { transform: translateY(-1px); background: rgba(255,255,255,0.28); }
    .filter-btn.selected { background:#fff; color:#111827; border-color:#fff; }

    .custom-popup__body { padding:12px 14px 14px 14px; background:#fafafa; }
    .table-wrap { background:#fff; border:1px solid #eef0f2; border-radius:12px; overflow:hidden; }
    table { border-collapse: collapse; width:100%; font-size:13px; table-layout:auto; }
    thead { background:#f3f4f6; }
    thead th { text-align:left; padding:10px 12px; font-weight:700; color:#111827; border-bottom:1px solid #e5e7eb; }
    thead th.price-per { text-align:center; }
    tbody td { padding:10px 12px; border-bottom:1px solid #f1f5f9; color:#111827; }
    tbody tr:hover { background:#f9fafb; }
    tbody td.price-per { text-align:center; }

    /* 구분 Pill */
    .pill { display:inline-block; padding:4px 8px; border-radius:9999px; font-weight:800; font-size:12px; white-space:nowrap; }
    .pill-real { background:#dcfce7; color:#166534; }
    .pill-auction { background:#fee2e2; color:#991b1b; }

    /* ====== 마커(원+숫자) ====== */
    .count-marker {
      width:34px; height:34px; border-radius:50%;
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:14px; font-weight:800;
      box-shadow:0 2px 8px rgba(0,0,0,0.25);
      border:2px solid rgba(255,255,255,0.7);
      user-select:none;
    }
    .marker-real { background:#16a34a; }
    .marker-auction { background:#ef4444; }
    .marker-mixed { background: conic-gradient(#16a34a 0 50%, #ef4444 50% 100%); }

    #optionInfo { font-weight:600; color:#111827; }

    /* 경매 필터 버튼 전용 */
    .filter-btn.auction {
      background:#ef4444;
      border-color:#ef4444;
      color:#fff;
    }
    .filter-btn.auction:hover {
      filter: brightness(0.95);
    }
    .filter-btn.auction.selected {
      background:#ef4444;
      border-color:#ef4444;
      color:#fff;
    }

    /* 기존 CSS 아래에 추가 */
    thead th .sort-arrow {
      margin-left: 4px;
      opacity: .65;
      font-size: 11px;
    }

    /* 평당가 정렬 화살표 */
    th.price-per .sort-arrow {
      margin-left: 4px;
      opacity: .65;
      font-size: 11px;
    }
  </style>
</head>
<body>

  <div id="controls">
    <label for="filter">위치:</label>
    <div id="optionInfo">지역</div>
    <label for="filter">유형:</label>
    <select id="filter">
      <option value="all">전체</option>
      <option value="real">실거래</option>
      <option value="auction">경매</option>
    </select>

    <div class="legend">
      <span class="legend-marker" style="background:#16a34a;"></span><span>실거래</span>
    </div>
    <div class="legend">
      <span class="legend-marker" style="background:#ef4444;"></span><span>경매</span>
    </div>
  </div>

  <div id="map"></div>

  <!-- 네이버 지도 SDK (v3 openAPI) -->
  <script src="https://oapi.map.naver.com/openapi/v3/maps.js?ncpKeyId=dd72ip9z43&submodules=geocoder"></script>
  <script>
    let currentOverlay = null;
    let markers = [];
    let addresses = null;
    let groups = [];
    let bounds = null;

    const map = new naver.maps.Map('map', {
      center: new naver.maps.LatLng(37.5665, 126.9780),
      zoom: 12
    });

    /* ===== 유틸 ===== */
    function parseDateKey(s) {
      if (!s) return -Infinity;
      const digits = String(s).replace(/[^\d]/g, '');
      if (digits.length === 8) return parseInt(digits, 10);
      if (digits.length === 6) return parseInt('20' + digits, 10);
      return parseInt(digits, 10) || -Infinity;
    }
    function extractIntString(val) {
      const m = String(val ?? '').match(/-?\d+(?:\.\d+)?/);
      if (!m) return '';
      const v = Math.trunc(parseFloat(m[0]));
      return String(v);
    }
    function typeMeta(items) {
      const hasReal = items.some(it => it.type === 'real');
      const hasAuction = items.some(it => it.type === 'auction');
      if (hasReal && hasAuction) return { marker:'marker-mixed', header:'type-mixed', label:'혼합', hasReal, hasAuction };
      if (hasReal) return { marker:'marker-real', header:'type-real', label:'실거래', hasReal:true, hasAuction:false };
      return { marker:'marker-auction', header:'type-auction', label:'경매', hasReal:false, hasAuction:true };
    }
    function cleanAuctionAddress(addr) {
      if (!addr) return addr;
      let s = String(addr);
      s = s.replace(/\s*,?\s*(지하?\d*층|\d+층|저층|고층)\s*[^\s,()]*호(?=\s*\()/gi, '');
      s = s.replace(/\s*,?\s*(지하?\d*층|\d+층|저층|고층)\s*(?=,|\(|$)/gi, '');
      s = s.replace(/\s*,?\s*[^\s,()]*호(?=,|\(|$)/gi, '');
      s = s.replace(/\s{2,}/g, ' ').replace(/\s*,\s*,/g, ',').replace(/\(\s*,\s*/g, '(').replace(/\s*,\s*\)/g, ')');
      return s.trim();
    }
    function groupByLocation(list) {
      const mp = new Map();
      for (const it of list) {
        const lat = parseFloat(it.latitude) || 0;
        const lng = parseFloat(it.longitude) || 0;
        const key = (lat && lng) ? `${lat.toFixed(6)},${lng.toFixed(6)}` : (it.address || '').trim();
        if (!key) continue;
        if (!mp.has(key)) mp.set(key, []);
        mp.get(key).push(it);
      }
      return Array.from(mp.entries()).map(([key, arr]) => {
        let lat = parseFloat(arr[0].latitude) || 0;
        let lng = parseFloat(arr[0].longitude) || 0;
        const address = (arr[0].address || '').trim();
        return { key, items: arr, lat, lng, address };
      });
    }
    function geocodeIfNeeded(group, done) {
      if (group.lat && group.lng) { done && done(group); return; }
      if (!group.address) { done && done(null); return; }
      naver.maps.Service.geocode({ query: group.address }, (status, response) => {
        if (status === naver.maps.Service.Status.OK && response.v2.addresses.length) {
          const addr = response.v2.addresses[0];
          group.lat = parseFloat(addr.y);
          group.lng = parseFloat(addr.x);
          done && done(group);
        } else { console.error('Geocode failed:', group.address, status); done && done(null); }
      });
    }

    function createCountMarker(group) {
      const meta = typeMeta(group.items);
      const count = group.items.length;
      const pos = new naver.maps.LatLng(group.lat, group.lng);

      const marker = new naver.maps.Marker({
        position: pos,
        map,
        icon: {
          content: `<div class="count-marker ${meta.marker}" title="${group.address}">${count}</div>`,
          anchor: new naver.maps.Point(17, 17) /* 원 34px 기준 */
        }
      });

      marker.addListener('click', () => openCustomPopup(group, pos));
      markers.push(marker);
      bounds.extend(pos);
    }

    /* 행 HTML 생성 (선택 필터에 맞게) */
    function buildRowsHTML(itemsSorted, selectedFilter) {
      const filtered = itemsSorted.filter(it => {
        if (selectedFilter === 'all') return true;
        return it.type === selectedFilter;
      });
      return filtered.map(it => {
        const date = it.date || '';
        const floorText = extractIntString(it.floor);
        const areaText  = extractIntString(it.area);
        const unitPrice = it.unitPrice ?? '';  // 이미 전처리된 값 사용
        const price = it.price ?? '';

        const isReal = it.type === 'real';
        const pillClass = isReal ? 'pill-real' : 'pill-auction';
        const pillText = isReal ? '실거래' : '경매';

        return `
          <tr>
            <td style="font-weight:800;"><span class="pill ${pillClass}">${pillText}</span></td>
            <td>${date}</td>
            <td>${floorText}</td>
            <td>${areaText}</td>
            <td class="price-per">${unitPrice}</td>
            <td style="text-align:right;">${price}</td>
          </tr>
        `;
      }).join('');
    }

    /* ===== 팝업 HTML 생성 ===== */
    function buildPopupHTML(group) {
      // 정렬: 실거래 → 경매, 각 구분 내부는 최신일자
      const itemsSorted = [...group.items].sort((a, b) => {
        const typeA = a.type === 'real' ? 0 : 1;
        const typeB = b.type === 'real' ? 0 : 1;
        if (typeA !== typeB) return typeA - typeB;
        return parseDateKey(b.date) - parseDateKey(a.date);
      });

      const meta = typeMeta(itemsSorted);
      const first = itemsSorted[0] || {};
      const building = first.building || first.apt_name || '';

      const headerAddr = (meta.label === '경매')
        ? cleanAuctionAddress(group.address || '주소 미상')
        : (group.address || '주소 미상');

      // 건수 계산
      const totalCount   = itemsSorted.length;
      const realCount    = itemsSorted.filter(it => it.type === 'real').length;
      const auctionCount = itemsSorted.filter(it => it.type === 'auction').length;

      // 필터 버튼 구성 (텍스트에 건수 포함)
      const filterOptions = [];
      if (meta.hasReal && meta.hasAuction) {
        filterOptions.push({key:'all',     text:`전체 (${totalCount})`});
        filterOptions.push({key:'real',    text:`실거래 (${realCount})`});
        filterOptions.push({key:'auction', text:`경매 (${auctionCount})`});
      } else if (meta.hasReal) {
        filterOptions.push({key:'real',    text:`실거래 (${realCount})`});
      } else {
        filterOptions.push({key:'auction', text:`경매 (${auctionCount})`});
      }
      const defaultFilter = filterOptions[0].key; // 혼합이면 all, 아니면 단일 항목

      // 필터 버튼 HTML
      const filterButtonsHTML = `
        <div class="popup-filters" data-filterbar>
          ${filterOptions.map((opt, idx) =>
            `<button class="filter-btn ${opt.key==='auction'?'auction':''} ${idx===0?'selected':''}" data-filter="${opt.key}">${opt.text}</button>`
          ).join('')}
        </div>
      `;

      // 초기 테이블 rows
      const initialRows = buildRowsHTML(itemsSorted, defaultFilter);

      return {
        html: `
          <div class="custom-popup ${meta.header}">
            <div class="custom-popup__header ${meta.header}">
              <div class="header-title">
                <div class="addr">${headerAddr}</div>
                ${building ? `<div class="bname">${building}</div>` : ``}
                ${filterButtonsHTML}
              </div>
              <div class="close-x" data-close>×</div>
            </div>
            <div class="custom-popup__body">
              <div class="table-wrap">
                <table>
                  <thead>
                    <tr>
                      <th>구분</th>
                      <th>거래일자</th>
                      <th>층</th>
                      <th class="area-col">평수</th>
                      <th class="price-per">평당가</th>
                      <th style="text-align:right;">금액</th>
                    </tr>
                  </thead>
                  <tbody data-tbody>
                    ${initialRows}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        `,
        itemsSorted,
        defaultFilter
      };
    }

    // === [ADD] 평수 숫자 파싱 헬퍼 ===
    function parseAreaNumber(v) {
      if (v == null) return NaN;
      const s = String(v).trim();
      if (s === '' || s === '-') return NaN;
      // 소수 포함 숫자만 추출 (예: '33.7평' → 33.7)
      const m = s.match(/-?\d+(?:\.\d+)?/);
      return m ? parseFloat(m[0]) : NaN;
    }

    // "36,000,000" / "36만" / "36만 원" / "-" 등에서 숫자만 뽑아 정렬용으로 사용
    function parseCurrencyNumber(v) {
      if (v == null) return NaN;
      const s = String(v).trim();
      if (s === '' || s === '-' ) return NaN;
      // "36만" 같은 경우를 대비: 만(=10,000) 단위 처리
      const manMatch = s.match(/(-?\d+(?:\.\d+)?)\s*만/);
      if (manMatch) return parseFloat(manMatch[1]) * 10000;
      // 일반 쉼표/문자 제거
      const num = s.replace(/[^\d.-]/g,'');
      return num ? parseFloat(num) : NaN;
    }

    /* ===== 커스텀 오버레이 ===== */
    class CustomPopup extends naver.maps.OverlayView {
      constructor(position, payload) {
        super();
        this._position = position;
        this._itemsSorted = payload.itemsSorted;
        this._currentFilter = payload.defaultFilter;
        this._pricePerSortDir = null; // null -> 'asc' -> 'desc' 토글 상태

        this._el = document.createElement('div');
        this._el.innerHTML = payload.html;
        this._container = this._el.firstElementChild;

        // 추가: 자동 스크롤 헬퍼
        const tableWrap = this._container.querySelector('.table-wrap');
        const tbody = this._container.querySelector('[data-tbody]');
        const applyAutoScroll = () => {
          const rows = tbody ? tbody.querySelectorAll('tr').length : 0;
          if (rows > 10) {
            tableWrap.style.maxHeight = '420px';    // 10행 정도 높이
            tableWrap.style.overflowY = 'auto';
          } else {
            tableWrap.style.maxHeight = '';
            tableWrap.style.overflowY = '';
          }
        };
        // 초기 적용
        applyAutoScroll();

        // 닫기
        this._container.querySelector('[data-close]')?.addEventListener('click', () => {
          this.setMap(null);
          if (currentOverlay === this) currentOverlay = null;
        });

        // 필터 클릭 (이벤트 위임)
        const filterBar = this._container.querySelector('[data-filterbar]');
        // const tbody = this._container.querySelector('[data-tbody]');
        if (filterBar && tbody) {
          filterBar.addEventListener('click', (e) => {
            const btn = e.target.closest('.filter-btn');
            if (!btn) return;
            const f = btn.getAttribute('data-filter');
            if (!f || f === this._currentFilter) return;

            // 버튼 selected 토글
            filterBar.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('selected'));
            btn.classList.add('selected');
            this._currentFilter = f;

            // 테이블 갱신
            tbody.innerHTML = buildRowsHTML(this._itemsSorted, this._currentFilter);
            // 정렬 상태 초기화 (필터 바꾸면 헤더 정렬도 초기화)
            this._pricePerSortDir = null;

            applyAutoScroll(); // ▼▼▼ 추가: 필터로 행 수 변동 시 적용
          });
        }
        // 정렬(거래일자)
        // === "거래일자" 헤더 클릭 시 정렬 토글(+ 화살표 표시) ===
        this._dateSortDir = null; // null -> 'asc' -> 'desc' 토글 상태
        const dateTh = this._container.querySelector('thead th:nth-child(2)');
        if (dateTh && tbody) {
          dateTh.style.cursor = 'pointer';
          dateTh.title = '거래일자로 정렬 (클릭 시 오름/내림차순 토글)';

          // 헤더 내부에 라벨/화살표 스팬이 없으면 주입
          let dateArrow = dateTh.querySelector('[data-date-arrow]');
          if (!dateArrow) {
            const label = document.createElement('span');
            label.textContent = '거래일자';
            const arrowSpan = document.createElement('span');
            arrowSpan.setAttribute('data-date-arrow', '');
            arrowSpan.className = 'sort-arrow';
            dateTh.textContent = '';            // 기존 텍스트 비우고
            dateTh.appendChild(label);          // 라벨
            dateTh.appendChild(arrowSpan);      // 화살표
            dateArrow = arrowSpan;
          }
          // ✅ 팝업 초기 표시 시 기본 화살표 표시
          dateArrow.textContent = '▼';  // 최신순(default)

          dateTh.addEventListener('click', () => {
            // 토글: null -> asc(오래된↑) -> desc(최신↓) -> asc ...
            this._dateSortDir = (this._dateSortDir === 'asc') ? 'desc' : 'asc';

            // 현재 필터 반영한 아이템
            const filtered = this._itemsSorted.filter(it => {
              return (this._currentFilter === 'all') || (it.type === this._currentFilter);
            });

            // 정렬: 날짜 파싱 (NaN/유효치 못한 날짜는 항상 뒤로)
            filtered.sort((a, b) => {
              const av = parseDateKey(a.date);
              const bv = parseDateKey(b.date);
              const aBad = !Number.isFinite(av) || av === -Infinity;
              const bBad = !Number.isFinite(bv) || bv === -Infinity;
              if (aBad && bBad) return 0;
              if (aBad) return 1;
              if (bBad) return -1;
              return this._dateSortDir === 'asc' ? (av - bv) : (bv - av);
            });

            // 렌더 (필터는 이미 적용했으니 'all'로 출력)
            tbody.innerHTML = buildRowsHTML(filtered, 'all');

            // 화살표 업데이트: asc=▲, desc=▼
            dateArrow.textContent = (this._dateSortDir === 'asc') ? '▲' : '▼';

            applyAutoScroll(); // ▼▼▼ 추가: 정렬로 행 수/높이 변화 시 적용
          });
        }
        // 평당가 헤더 클릭 정렬
        // === "평당가" 헤더 클릭 시 정렬 토글 ===
        const pricePerTh = this._container.querySelector('th.price-per');
        if (pricePerTh && tbody) {
          pricePerTh.style.cursor = 'pointer';
          pricePerTh.title = '평당가로 정렬 (클릭 시 오름/내림차순 토글)';

          // 1) 헤더 내부에 라벨/화살표 스팬이 없으면 주입
          let arrow = pricePerTh.querySelector('[data-sort-arrow]');
          if (!arrow) {
            const label = document.createElement('span');
            label.textContent = '평당가';
            const arrowSpan = document.createElement('span');
            arrowSpan.setAttribute('data-sort-arrow', '');
            arrowSpan.className = 'sort-arrow';
            pricePerTh.textContent = ''; // 기존 텍스트 지우고
            pricePerTh.appendChild(label);
            pricePerTh.appendChild(arrowSpan);
            arrow = arrowSpan;
          }
          // ✅ 팝업 초기 표시 시 기본 화살표 표시
          arrow.textContent = '▼';  // 최신순(default)

          pricePerTh.addEventListener('click', () => {
            // 토글: null -> asc -> desc -> asc ...
            this._pricePerSortDir = (this._pricePerSortDir === 'asc') ? 'desc' : 'asc';

            // 현재 필터 반영한 아이템
            const filtered = this._itemsSorted.filter(it => {
              return (this._currentFilter === 'all') || (it.type === this._currentFilter);
            });

            // 정렬: NaN(숫자 아님)은 항상 뒤로
            filtered.sort((a, b) => {
              const av = parseCurrencyNumber(a.unitPrice);
              const bv = parseCurrencyNumber(b.unitPrice);
              const aNaN = Number.isNaN(av), bNaN = Number.isNaN(bv);
              if (aNaN && bNaN) return 0;
              if (aNaN) return 1;
              if (bNaN) return -1;
              return this._pricePerSortDir === 'asc' ? (av - bv) : (bv - av);
            });

            // 렌더
            tbody.innerHTML = buildRowsHTML(filtered, 'all');
            // buildRowsHTML의 필터는 이미 filtered에서 적용했으므로 'all'로 출력
            // 2) 화살표 업데이트
            arrow.textContent = (this._pricePerSortDir === 'asc') ? '▲' : '▼';

            applyAutoScroll(); // ▼▼▼ 추가: 정렬로 행 수/높이 변화 시 적용
          });
        }
        // === [ADD] "평수" 헤더 클릭 정렬 ===
        // 요구사항: 평수 기준 정렬(asc/desc 토글) + 2차 정렬은 '날짜 최신순(desc)'
        // (실거래/경매 구분 없이: 타입별 선정렬 없이 숫자→날짜로만 정렬)
        this._areaSortDir = null;
        const areaTh = this._container.querySelector('th.area-col');
        if (areaTh && tbody) {
          areaTh.style.cursor = 'pointer';
          areaTh.title = '평수로 정렬 (클릭 시 오름/내림차순 토글)';

          // 헤더에 라벨/화살표 주입
          let areaArrow = areaTh.querySelector('[data-area-arrow]');
          if (!areaArrow) {
              const label = document.createElement('span');
              label.textContent = '평수';
              const arrowSpan = document.createElement('span');
              arrowSpan.setAttribute('data-area-arrow', '');
              arrowSpan.className = 'sort-arrow';
              areaTh.textContent = '';          // 기존 텍스트 제거
              areaTh.appendChild(label);        // 라벨
              areaTh.appendChild(arrowSpan);    // 화살표
              areaArrow = arrowSpan;
          }
          // 초기 표시는 기본(정렬 전)이므로 화살표 공백 유지 또는 필요 시 '▼'로 표시 가능
          areaArrow.textContent = '▼';

          areaTh.addEventListener('click', () => {
            // 토글: null -> asc -> desc -> asc ...
            this._areaSortDir = (this._areaSortDir === 'asc') ? 'desc' : 'asc';

            // 현재 필터 상태 반영 (all/real/auction)
            const filtered = this._itemsSorted.filter(it => {
              return (this._currentFilter === 'all') || (it.type === this._currentFilter);
            });

            // 1차: 평수 숫자 정렬(오름/내림) — NaN은 항상 뒤
            // 2차: 날짜 최신순(desc)
            filtered.sort((a, b) => {
              const av = parseAreaNumber(a.area);
              const bv = parseAreaNumber(b.area);
              const aNaN = Number.isNaN(av), bNaN = Number.isNaN(bv);
              if (aNaN && bNaN) {
                // 둘 다 NaN이면 날짜 최신순(desc)만 비교
                const ad = parseDateKey(a.date);
                const bd = parseDateKey(b.date);
                return (bd - ad);
              }
              if (aNaN) return 1;
              if (bNaN) return -1;

              if (this._areaSortDir === 'asc') {
                if (av !== bv) return av - bv;
              } else {
                if (av !== bv) return bv - av;
              }
              // 평수가 같다면 날짜 최신순(desc)
              const ad = parseDateKey(a.date);
              const bd = parseDateKey(b.date);
              return (bd - ad);
            });

            // 렌더 (필터로 이미 거른 배열이므로 'all'로 출력)
            tbody.innerHTML = buildRowsHTML(filtered, 'all');

            // 화살표 업데이트
            areaArrow.textContent = (this._areaSortDir === 'asc') ? '▲' : '▼';

            applyAutoScroll(); // ▼▼▼ 추가: 정렬로 행 수/높이 변화 시 적용
          });
        }
        // === 여기까지 "평수" 정렬 추가 ===
      }

      onAdd() { this.getPanes().floatPane.appendChild(this._container); }
      draw() {
        const proj = this.getProjection(); if (!proj) return;
        const pos = proj.fromCoordToOffset(this._position);
        this._container.style.left = `${pos.x}px`;
        this._container.style.top  = `${pos.y}px`;
      }
      onRemove() {
        if (this._container?.parentNode) this._container.parentNode.removeChild(this._container);
        this._container = null;
      }
      setPosition(latlng) { this._position = latlng; this.draw(); }
    }

    function openCustomPopup(group, position) {
      if (currentOverlay) { currentOverlay.setMap(null); currentOverlay = null; }
      const payload = buildPopupHTML(group);
      const overlay = new CustomPopup(position, payload);
      overlay.setMap(map);
      currentOverlay = overlay;
    }

    /* ===== 렌더링 파이프라인 ===== */
    function plotByType(type) {
      markers.forEach(m => m.setMap(null));
      markers = [];
      bounds = new naver.maps.LatLngBounds();
      if (currentOverlay) { currentOverlay.setMap(null); currentOverlay = null; }

      if (!Array.isArray(addresses) || addresses.length === 0) return;

      const filtered = addresses.filter(a => type === 'all' || a.type === type);
      if (filtered.length === 0) return;

      groups = groupByLocation(filtered);

      let doneCount = 0;
      const total = groups.length;
      groups.forEach(g => {
        geocodeIfNeeded(g, (result) => {
          doneCount++;
          if (!result) return;
          createCountMarker(g);
          if (doneCount === total && markers.length) map.fitBounds(bounds);
        });
      });
    }

    /* ===== 이벤트 ===== */
    document.getElementById('filter').addEventListener('change', function() {
      plotByType(this.value);
    });

    naver.maps.Event.addListener(map, 'click', () => {
      if (currentOverlay) { currentOverlay.setMap(null); currentOverlay = null; }
    });

    window.addEventListener('message', function(event) {
      // if (event.origin !== window.location.origin) return;
      const data = event.data;

      if (Array.isArray(data.options)) {
        const optionDiv = document.getElementById('optionInfo');
        const formatted = data.options.map(opt => {
          const yearText  = opt.year ? `${opt.year}년` : '';
          const floorText = opt.floor || '';
          const areaText  = opt.area || '';
          return `${opt.region}(${[yearText, floorText, areaText].filter(Boolean).join('/')})`;
        }).join(' / ');
        optionDiv.textContent = formatted || '지역';
      }

      if (Array.isArray(data.addresses)) {
        addresses = data.addresses;
        plotByType('all');
      }
    });

    // 테스트용
    // window.postMessage({addresses:[
    //   {address:'서울 중구 세종대로 110', type:'real', date:'2025-08-30', floor:'10층', area:'33.7평', unitPrice:'36,000,000', price:'1,200,000,000', apt_name:'테스트빌딩'},
    //   {address:'서울 중구 세종대로 110', type:'real', date:'2025-08-28', floor:'12층', area:'25평', unitPrice:'32,000,000', price:'800,000,000', apt_name:'테스트빌딩'},
    //   {address:'서울 중구 세종대로 110, 1층 101호(중구,테스트빌딩)', type:'auction', date:'2025-08-27', floor:'1층 101호', area:'33평', unitPrice:'-', price:'120,000,000', apt_name:'테스트빌딩'}
    // ]}, "*");
  </script>
</body>
</html>
